<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsidplayfp: exSID.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsidplayfp
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c8052a5d5fc54a3d1b6e0aaa42744e96.html">builders</a></li><li class="navelem"><a class="el" href="dir_72b54144977f20270a1b83a5c0f43219.html">exsid-builder</a></li><li class="navelem"><a class="el" href="dir_9cf97136e2b716fe61d4c5d5daf5264e.html">driver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">exSID.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="exSID_8h_source.html">exSID.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="exSID__defs_8h_source.html">exSID_defs.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="exSID__ftdiwrap_8h_source.html">exSID_ftdiwrap.h</a>&quot;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for exSID.c:</div>
<div class="dyncontent">
<div class="center"><img src="exSID_8c__incl.png" border="0" usemap="#exSID_8c" alt=""/></div>
<map name="exSID_8c" id="exSID_8c">
<area shape="rect" id="node2" href="exSID_8h.html" title="exSID.h" alt="" coords="5,80,77,107"/>
<area shape="rect" id="node4" href="exSID__defs_8h.html" title="exSID_defs.h" alt="" coords="101,80,208,107"/>
<area shape="rect" id="node5" href="exSID__ftdiwrap_8h.html" title="exSID_ftdiwrap.h" alt="" coords="232,80,365,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxSconsts__s.html">xSconsts_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__exsid.html">_exsid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6242a25f9d996f0cc4f4cdb911218b75"><td class="memItemLeft" align="right" valign="top"><a id="a6242a25f9d996f0cc4f4cdb911218b75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ARRAY_SIZE</b>(x)&#160;&#160;&#160;(sizeof(x) / sizeof(x[0]))</td></tr>
<tr class="separator:a6242a25f9d996f0cc4f4cdb911218b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae968a49b07f07f05fe403fecbb3dba0d"><td class="memItemLeft" align="right" valign="top"><a id="ae968a49b07f07f05fe403fecbb3dba0d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>XS_ERRORBUF</b>&#160;&#160;&#160;256</td></tr>
<tr class="separator:ae968a49b07f07f05fe403fecbb3dba0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1912f08975fb84075f586bca506014"><td class="memItemLeft" align="right" valign="top"><a id="aea1912f08975fb84075f586bca506014"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>xserror</b>(xs,  format, ...)&#160;&#160;&#160;snprintf(xs-&gt;xSerrstr, XS_ERRORBUF, &quot;(%s) ERROR &quot; format, __func__, ## __VA_ARGS__)</td></tr>
<tr class="separator:aea1912f08975fb84075f586bca506014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae2ae545ee48d26354c7b6c44db6347c5"><td class="memItemLeft" align="right" valign="top">typedef int_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#ae2ae545ee48d26354c7b6c44db6347c5">clkdrift_t</a></td></tr>
<tr class="separator:ae2ae545ee48d26354c7b6c44db6347c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aba733a0b33d834d8feea11a6a9a7c858"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#aba733a0b33d834d8feea11a6a9a7c858">exSID_error_str</a> (void *const exsid)</td></tr>
<tr class="separator:aba733a0b33d834d8feea11a6a9a7c858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118545ecf5b2378f1d3a3ec077981745"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#a118545ecf5b2378f1d3a3ec077981745">exSID_new</a> (void)</td></tr>
<tr class="separator:a118545ecf5b2378f1d3a3ec077981745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cfadc5873a50a0686dca3887012aab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#a23cfadc5873a50a0686dca3887012aab">exSID_free</a> (void *exsid)</td></tr>
<tr class="separator:a23cfadc5873a50a0686dca3887012aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab804a6f81139b6a6a68b78d85b05976a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#ab804a6f81139b6a6a68b78d85b05976a">exSID_init</a> (void *const exsid)</td></tr>
<tr class="separator:ab804a6f81139b6a6a68b78d85b05976a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb07e0bbede1e79c024ae034d36d663c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#aeb07e0bbede1e79c024ae034d36d663c">exSID_exit</a> (void *const exsid)</td></tr>
<tr class="separator:aeb07e0bbede1e79c024ae034d36d663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e789ae5240cda76b39706a7b7ea7cfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#a3e789ae5240cda76b39706a7b7ea7cfb">exSID_reset</a> (void *const exsid)</td></tr>
<tr class="separator:a3e789ae5240cda76b39706a7b7ea7cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d98fbacbc651403c6a342b179915f10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#a9d98fbacbc651403c6a342b179915f10">exSID_clockselect</a> (void *const exsid, int clock)</td></tr>
<tr class="separator:a9d98fbacbc651403c6a342b179915f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad054cf25b70a00a572f4f5f5c70de6c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#ad054cf25b70a00a572f4f5f5c70de6c7">exSID_audio_op</a> (void *const exsid, int operation)</td></tr>
<tr class="separator:ad054cf25b70a00a572f4f5f5c70de6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa4ac43fb7553ea2856028972a332e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#acfa4ac43fb7553ea2856028972a332e6">exSID_chipselect</a> (void *const exsid, int chip)</td></tr>
<tr class="separator:acfa4ac43fb7553ea2856028972a332e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056f37d5225f673d1dd9e047d353024b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#a056f37d5225f673d1dd9e047d353024b">exSID_hwmodel</a> (void *const exsid)</td></tr>
<tr class="separator:a056f37d5225f673d1dd9e047d353024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17f7c0fbf7e2b038939718f3fe23584"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#ac17f7c0fbf7e2b038939718f3fe23584">exSID_hwversion</a> (void *const exsid)</td></tr>
<tr class="separator:ac17f7c0fbf7e2b038939718f3fe23584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ff3afd894f5867d566a83c10574a97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#ac3ff3afd894f5867d566a83c10574a97">exSID_delay</a> (void *const exsid, uint_fast32_t cycles)</td></tr>
<tr class="separator:ac3ff3afd894f5867d566a83c10574a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec94b12c6fef757ab3890e88fda05274"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#aec94b12c6fef757ab3890e88fda05274">exSID_clkdwrite</a> (void *const exsid, uint_fast32_t cycles, uint_least8_t addr, uint8_t data)</td></tr>
<tr class="separator:aec94b12c6fef757ab3890e88fda05274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07c6acba47da84783df0624c593fdeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="exSID_8c.html#af07c6acba47da84783df0624c593fdeb">exSID_clkdread</a> (void *const exsid, uint_fast32_t cycles, uint_least8_t addr, uint8_t *data)</td></tr>
<tr class="separator:af07c6acba47da84783df0624c593fdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>exSID/exSID+ USB I/O library </p><dl class="section author"><dt>Author</dt><dd>Thibaut VARENE </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2015-2018,2021 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>2.1</dd></dl>
<p>This driver will control the first exSID device available. All public API functions are only valid after a successful call to <a class="el" href="exSID_8c.html#ab804a6f81139b6a6a68b78d85b05976a">exSID_init()</a>. To release the device and resources, <a class="el" href="exSID_8c.html#aeb07e0bbede1e79c024ae034d36d663c">exSID_exit()</a> and <a class="el" href="exSID_8c.html#a23cfadc5873a50a0686dca3887012aab">exSID_free()</a> must be called.</p>
<p>The return value for public routines returning an integer is 0 for successful execution and !0 for error, unless otherwise noted.</p>
<dl class="section warning"><dt>Warning</dt><dd>Although it can internally make use of two separate threads, the driver implementation is NOT thread safe (since it is not expected that a SID device may be accessed concurrently), and some optimizations in the code are based on the assumption that the code is run within a single-threaded environment. </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae2ae545ee48d26354c7b6c44db6347c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ae545ee48d26354c7b6c44db6347c5">&#9670;&nbsp;</a></span>clkdrift_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast32_t <a class="el" href="exSID_8c.html#ae2ae545ee48d26354c7b6c44db6347c5">clkdrift_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cycles is uint_fast32_t. Technically, clkdrift should be int_fast64_t though overflow should not happen under normal conditions. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad054cf25b70a00a572f4f5f5c70de6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad054cf25b70a00a572f4f5f5c70de6c7">&#9670;&nbsp;</a></span>exSID_audio_op()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_audio_op </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>exSID+ audio operations routine. Selects the audio mixing / muting option. Only implemented in exSID+ devices. </p><dl class="section warning"><dt>Warning</dt><dd>all these operations (excepting unmuting obviously) will mute the output by default. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>no accounting for SID cycles consumed (not expected to be used during playback). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
    <tr><td class="paramname">operation</td><td>audio operation value, see <a class="el" href="exSID_8h.html">exSID.h</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>execution status </dd></dl>

</div>
</div>
<a id="acfa4ac43fb7553ea2856028972a332e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa4ac43fb7553ea2856028972a332e6">&#9670;&nbsp;</a></span>exSID_chipselect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_chipselect </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SID chipselect routine. Selects which SID will play the tunes. </p><dl class="section note"><dt>Note</dt><dd>Accounts for elapsed cycles. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
    <tr><td class="paramname">chip</td><td>SID selector value, see <a class="el" href="exSID_8h.html">exSID.h</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>execution status </dd></dl>

</div>
</div>
<a id="af07c6acba47da84783df0624c593fdeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07c6acba47da84783df0624c593fdeb">&#9670;&nbsp;</a></span>exSID_clkdread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_clkdread </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>BLOCKING Timed read routine, attempts cycle-accurate reads. The following description is based on exSID (standard). This function will be cycle-accurate provided that no two consecutive reads or writes are less than XS_CYCIO apart and leftover delay is &lt;= max_adj SID clock cycles. Read result will only be available after a full XS_CYCIO, giving clkdread() the same run time as clkdwrite(). There's a 2-cycle negative adjustment in the code because that's the actual offset from the write calls ('/' denotes falling clock edge latch), which the following ASCII tries to illustrate: <br />
 Write looks like this in firmware: </p><blockquote class="doxtable">
<p>...|_/_|... </p>
</blockquote>
<p>...end of data byte read | cycle during which write is enacted / next cycle | etc... <br />
 Read looks like this in firmware: </p><blockquote class="doxtable">
<p>...|_|_|_/_|_|... </p>
</blockquote>
<p>...end of address byte read | 2 cycles for address processing | cycle during which SID is read / then half a cycle later the CYCCHR-long data TX starts, cycle completes | another cycle | etc... <br />
 This explains why reads happen a relative 2-cycle later than then should with respect to writes. </p><dl class="section warning"><dt>Warning</dt><dd>this function is only valid if EXSID_THREADED is not defined. If it is called when EXSID_THREADED is defined, no read will be performed, however the requested cycles will still be clocked. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function accepts reads from invalid addresses (addr &lt; 0x19 or addr &gt; 0x1c). If DEBUG is enabled it will not pass them to the hardware and return 1. Elapsed SID cycles will still be accounted for. </dd>
<dd>
The actual time the read will take to complete depends on the USB bus activity and settings. It <em>should</em> complete in XSC_USBLAT ms, but not less, meaning that read operations are bound to introduce timing inaccuracy. As such, this function is only really provided as a proof of concept but SHOULD BETTER BE AVOIDED. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
    <tr><td class="paramname">cycles</td><td>how many SID clocks to wait before the actual data read. </td></tr>
    <tr><td class="paramname">addr</td><td>target address. </td></tr>
    <tr><td class="paramname">data</td><td>pointer to store data read from address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if error, 0 on success </dd></dl>

</div>
</div>
<a id="aec94b12c6fef757ab3890e88fda05274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec94b12c6fef757ab3890e88fda05274">&#9670;&nbsp;</a></span>exSID_clkdwrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_clkdwrite </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timed write routine, attempts cycle-accurate writes. This function will be cycle-accurate provided that no two consecutive writes are less than write_cycles apart and the leftover delay is &lt;= max_adj SID clock cycles. </p><dl class="section note"><dt>Note</dt><dd>this function accepts writes to invalid addresses (&gt; 0x18). If DEBUG is enabled it will not pass them to the hardware and return 1. Elapsed SID cycles will still be accounted for. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
    <tr><td class="paramname">cycles</td><td>how many SID clocks to wait before the actual data write. </td></tr>
    <tr><td class="paramname">addr</td><td>target address. </td></tr>
    <tr><td class="paramname">data</td><td>data to write at that address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if error, 0 on success </dd></dl>

</div>
</div>
<a id="a9d98fbacbc651403c6a342b179915f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d98fbacbc651403c6a342b179915f10">&#9670;&nbsp;</a></span>exSID_clockselect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_clockselect </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>exSID+ clock selection routine. Selects between PAL, NTSC and 1MHz clocks. Only implemented in exSID+ devices. </p><dl class="section note"><dt>Note</dt><dd>upon clock change the hardware resync itself and resets the SIDs, which takes approximately 50us: this call introduces a stall in the stream and resets the internal drift adjustment counter. Output should be muted before execution. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
    <tr><td class="paramname">clock</td><td>clock selector value, see <a class="el" href="exSID_8h.html">exSID.h</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>execution status </dd></dl>

</div>
</div>
<a id="ac3ff3afd894f5867d566a83c10574a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ff3afd894f5867d566a83c10574a97">&#9670;&nbsp;</a></span>exSID_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_delay </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast32_t&#160;</td>
          <td class="paramname"><em>cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cycle accurate delay routine. Delay for cycles SID clocks while leaving enough lead time for an I/O operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
    <tr><td class="paramname">cycles</td><td>how many SID clocks to loop for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error and 1 if the requested number of cycles is smaller than the feasible delay </dd></dl>

</div>
</div>
<a id="aba733a0b33d834d8feea11a6a9a7c858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba733a0b33d834d8feea11a6a9a7c858">&#9670;&nbsp;</a></span>exSID_error_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* exSID_error_str </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string describing the last recorded error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error message (max 256 bytes long). </dd></dl>

</div>
</div>
<a id="aeb07e0bbede1e79c024ae034d36d663c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb07e0bbede1e79c024ae034d36d663c">&#9670;&nbsp;</a></span>exSID_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_exit </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device exit routine. Must be called to release the device. Resets the SIDs, frees buffers and closes FTDI device. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>execution status </dd></dl>

</div>
</div>
<a id="a23cfadc5873a50a0686dca3887012aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cfadc5873a50a0686dca3887012aab">&#9670;&nbsp;</a></span>exSID_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exSID_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>exsid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocate an exSID handle. Frees up all memory used by the exSID handle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a056f37d5225f673d1dd9e047d353024b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056f37d5225f673d1dd9e047d353024b">&#9670;&nbsp;</a></span>exSID_hwmodel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_hwmodel </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device hardware model. Queries the driver for the hardware model currently identified. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hardware model as enumerated in <a class="el" href="exSID_8h.html">exSID.h</a>, negative value on error. </dd></dl>

</div>
</div>
<a id="ac17f7c0fbf7e2b038939718f3fe23584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17f7c0fbf7e2b038939718f3fe23584">&#9670;&nbsp;</a></span>exSID_hwversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t exSID_hwversion </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hardware and firmware version of the device. Returns both in the form of a 16bit integer: MSB is an ASCII character representing the hardware revision (e.g. 0x42 = "B"), and LSB is a number representing the firmware version in decimal integer. Does not reach the hardware (information is fetched once in <a class="el" href="exSID_8c.html#ab804a6f81139b6a6a68b78d85b05976a">exSID_init()</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>version information as described above, or 0xFFFF if error. </dd></dl>

</div>
</div>
<a id="ab804a6f81139b6a6a68b78d85b05976a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab804a6f81139b6a6a68b78d85b05976a">&#9670;&nbsp;</a></span>exSID_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_init </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Device init routine. Must be called once before any operation is attempted on the device. Opens first available device, and sets various parameters: baudrate, parity, flow control and USB latency. </p><dl class="section note"><dt>Note</dt><dd>If this function fails, <a class="el" href="exSID_8c.html#a23cfadc5873a50a0686dca3887012aab">exSID_free()</a> must still be called. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>allocated exsid handle generated with <a class="el" href="exSID_8c.html#a118545ecf5b2378f1d3a3ec077981745">exSID_new()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, !0 otherwise. </dd></dl>

</div>
</div>
<a id="a118545ecf5b2378f1d3a3ec077981745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118545ecf5b2378f1d3a3ec077981745">&#9670;&nbsp;</a></span>exSID_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* exSID_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate an exSID handle. </p><dl class="section return"><dt>Returns</dt><dd>allocated opaque handle, NULL if error. </dd></dl>

</div>
</div>
<a id="a3e789ae5240cda76b39706a7b7ea7cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e789ae5240cda76b39706a7b7ea7cfb">&#9670;&nbsp;</a></span>exSID_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int exSID_reset </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>exsid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SID reset routine. Performs a hardware reset on the SIDs. This also resets the internal drift adjustment counter. </p><dl class="section note"><dt>Note</dt><dd>since the reset procedure in firmware will stall the device, reset can wait before resuming execution. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exsid</td><td>exsid handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>execution status </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 12 2021 13:19:55 for libsidplayfp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
